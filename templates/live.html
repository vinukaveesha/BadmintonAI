{% extends "base.html" %}
{% block content %}
<div class="container">
    <h2>Live Shot Recognition</h2>
    <div class="row">
        <div class="col-md-6">
            <video id="preview" width="100%" autoplay muted></video>
            <div id="countdown" class="text-danger mb-2"></div>
            <button id="recordBtn" class="btn btn-primary" onclick="startRecording()">
                Start Recording (5 seconds)
            </button>
            <div id="result" class="mt-3">
                <h4>Prediction: <span id="predictionResult" class="text-primary">-</span></h4>
                <h4>Confidence: <span id="confidenceResult" class="text-primary">-</span>%</h4>
            </div>
        </div>
        <div class="col-md-6">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Instructions</h5>
                    <ol>
                        <li>Position yourself in full view of the camera</li>
                        <li>Click "Start Recording"</li>
                        <li>Perform your shot within 5 seconds</li>
                        <li>View your results automatically</li>
                    </ol>
                    <p class="text-muted">Ensure good lighting and clear background for best results.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
let mediaRecorder;
let recordedChunks = [];
let isRecording = false;

async function startRecording() {
    if (isRecording) return;
    
    try {
        isRecording = true;
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { width: 640, height: 480 },
            audio: false
        });
        
        const preview = document.getElementById('preview');
        preview.srcObject = stream;
        
        mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9'
        });

        mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) recordedChunks.push(e.data);
        };

        mediaRecorder.onstop = async () => {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            recordedChunks = [];
            
            document.getElementById('result').classList.add('processing');
            
            const formData = new FormData();
            formData.append('file', blob, 'recording.webm');

            try {
                const response = await fetch('/predict', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.error) throw new Error(result.error);
                
                document.getElementById('predictionResult').textContent = result.prediction;
                document.getElementById('confidenceResult').textContent = result.confidence;
            } catch (error) {
                console.error('Error:', error);
                alert(`Classification failed: ${error.message}`);
            } finally {
                document.getElementById('result').classList.remove('processing');
            }
        };

        mediaRecorder.start();
        document.getElementById('recordBtn').disabled = true;
        let seconds = 5;
        const countdownElement = document.getElementById('countdown');
        
        const timer = setInterval(() => {
            countdownElement.textContent = `Recording... ${seconds}s remaining`;
            if (seconds-- <= 0) {
                clearInterval(timer);
                countdownElement.textContent = '';
                mediaRecorder.stop();
                stream.getTracks().forEach(track => track.stop());
                document.getElementById('recordBtn').disabled = false;
                isRecording = false;
            }
        }, 1000);

    } catch (error) {
        console.error('Error accessing camera:', error);
        alert('Camera access required for live recognition');
        isRecording = false;
    }
}
</script>

<style>
#preview {
    border: 2px solid #ddd;
    border-radius: 8px;
    background: #000;
}

#result.processing {
    position: relative;
    opacity: 0.6;
}

#result.processing::after {
    content: "Analyzing...";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.8);
    font-weight: bold;
    color: #0d6efd;
}
</style>
{% endblock %}